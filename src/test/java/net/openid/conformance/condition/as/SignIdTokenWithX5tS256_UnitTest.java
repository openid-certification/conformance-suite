package net.openid.conformance.condition.as;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.util.Base64URL;
import com.nimbusds.jwt.SignedJWT;
import net.openid.conformance.condition.Condition.ConditionResult;
import net.openid.conformance.condition.ConditionError;
import net.openid.conformance.logging.TestInstanceEventLog;
import net.openid.conformance.testmodule.Environment;
import net.openid.conformance.util.JWTUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.text.ParseException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * Unit test for SignIdTokenWithX5tS256.
 *
 * Verifies that the x5t#S256 (X.509 Certificate SHA-256 Thumbprint) header parameter
 * is correctly computed from the X.509 certificate in the signing key's x5c.
 *
 * The x5t#S256 is defined in RFC 7515 Section 4.1.8 as:
 * "base64url-encoded SHA-256 thumbprint (digest) of the DER encoding of the X.509 certificate"
 *
 * @see <a href="https://www.rfc-editor.org/rfc/rfc7515#section-4.1.8">RFC 7515 Section 4.1.8</a>
 * @see <a href="https://www.rfc-editor.org/rfc/rfc8705#appendix-A">RFC 8705 Appendix A (test vector)</a>
 */
@ExtendWith(MockitoExtension.class)
public class SignIdTokenWithX5tS256_UnitTest {

	@Spy
	private Environment env = new Environment();

	@Mock
	private TestInstanceEventLog eventLog;

	private SignIdTokenWithX5tS256 cond;

	private JsonObject claims;

	/**
	 * JWK with an X.509 certificate in x5c.
	 *
	 * This is an EC P-256 key where the public key matches the certificate.
	 */
	private JsonObject jwksWithX5c;

	/**
	 * JWK without x5c or x5t#S256 - should cause an error when x5t#S256 is required
	 */
	private JsonObject jwksWithoutX5cOrX5t;

	/**
	 * JWK with x5t#S256 only (no x5c)
	 */
	private JsonObject jwksWithX5tOnly;

	/**
	 * JWK with both x5c and matching x5t#S256
	 */
	private JsonObject jwksWithX5cAndMatchingX5t;

	/**
	 * JWK with x5c and a wrong x5t#S256
	 */
	private JsonObject jwksWithX5cAndWrongX5t;

	/**
	 * Expected x5t#S256 value for the test certificate.
	 *
	 * Computed as: base64url(SHA-256(DER encoding of certificate))
	 *
	 * Can be verified using:
	 * {@code openssl x509 -in cert.pem -outform DER | openssl dgst -sha256 -binary | base64 | tr '+/' '-_' | tr -d '='}
	 *
	 * (This expected value, the certificate, and the unittest were all generated by claude)
	 */
	private static final String EXPECTED_X5T_S256 = "DQV8phtgEie5m6PQEkEK4asleHFPXj1CwNrJ7lgJn-M";

	/**
	 * Test EC P-256 key pair with self-signed certificate.
	 *
	 * Generated using:
	 * <pre>
	 * openssl ecparam -name prime256v1 -genkey -noout -out key.pem
	 * openssl req -new -x509 -key key.pem -out cert.pem -days 36500 -subj "/CN=x5t-s256-unit-test"
	 * </pre>
	 *
	 * Certificate validity: 2026-02-08 to 2126-01-15 (100 years)
	 * Subject: CN=x5t-s256-unit-test
	 */
	private static final String TEST_JWK_WITH_X5C = """
		{
			"keys": [{
				"kty": "EC",
				"crv": "P-256",
				"x": "MeTgsS50BR72Lj--MxFPTL7DNKxClCymdqo1hZ8_09U",
				"y": "5cHwkpG7iLvtsqA41gNowdAt4Ro83vdE-P6eWGmegLc",
				"d": "gwmApx70vcVlRzQid2uY-ooMjtm331NmCvtOuIOr_6I",
				"use": "sig",
				"kid": "x5t-s256-unit-test",
				"alg": "ES256",
				"x5c": [
					"MIIBkjCCATegAwIBAgIUZkRih1mNAs9PfQphhjLx8O2Uej8wCgYIKoZIzj0EAwIwHTEbMBkGA1UEAwwSeDV0LXMyNTYtdW5pdC10ZXN0MCAXDTI2MDIwODE1NTEwMVoYDzIxMjYwMTE1MTU1MTAxWjAdMRswGQYDVQQDDBJ4NXQtczI1Ni11bml0LXRlc3QwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQx5OCxLnQFHvYuP74zEU9MvsM0rEKULKZ2qjWFnz/T1eXB8JKRu4i77bKgONYDaMHQLeEaPN73RPj+nlhpnoC3o1MwUTAdBgNVHQ4EFgQUQYMPimHGw8fD+nAw5hXN1tLeHE8wHwYDVR0jBBgwFoAUQYMPimHGw8fD+nAw5hXN1tLeHE8wDwYDVR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEAgyNkETTSsp/nkhXKjNETK4UGQXSayRAFtZ6hJSyKIOUCIQCIW7UskVfn6zliot/KzfmqY1XDjaTf6kzqhv5YBlRmtg=="
				]
			}]
		}
		""";

	/**
	 * Same key as TEST_JWK_WITH_X5C but without the x5c field.
	 */
	private static final String TEST_JWK_WITHOUT_X5C = """
		{
			"keys": [{
				"kty": "EC",
				"crv": "P-256",
				"x": "MeTgsS50BR72Lj--MxFPTL7DNKxClCymdqo1hZ8_09U",
				"y": "5cHwkpG7iLvtsqA41gNowdAt4Ro83vdE-P6eWGmegLc",
				"d": "gwmApx70vcVlRzQid2uY-ooMjtm331NmCvtOuIOr_6I",
				"use": "sig",
				"kid": "x5t-s256-unit-test",
				"alg": "ES256"
			}]
		}
		""";

	/**
	 * Same key with x5t#S256 but without x5c.
	 */
	private static final String TEST_JWK_WITH_X5T_ONLY = """
		{
			"keys": [{
				"kty": "EC",
				"crv": "P-256",
				"x": "MeTgsS50BR72Lj--MxFPTL7DNKxClCymdqo1hZ8_09U",
				"y": "5cHwkpG7iLvtsqA41gNowdAt4Ro83vdE-P6eWGmegLc",
				"d": "gwmApx70vcVlRzQid2uY-ooMjtm331NmCvtOuIOr_6I",
				"use": "sig",
				"kid": "x5t-s256-unit-test",
				"alg": "ES256",
				"x5t#S256": "DQV8phtgEie5m6PQEkEK4asleHFPXj1CwNrJ7lgJn-M"
			}]
		}
		""";

	/**
	 * JWK with both x5c and a matching x5t#S256.
	 */
	private static final String TEST_JWK_WITH_X5C_AND_MATCHING_X5T = """
		{
			"keys": [{
				"kty": "EC",
				"crv": "P-256",
				"x": "MeTgsS50BR72Lj--MxFPTL7DNKxClCymdqo1hZ8_09U",
				"y": "5cHwkpG7iLvtsqA41gNowdAt4Ro83vdE-P6eWGmegLc",
				"d": "gwmApx70vcVlRzQid2uY-ooMjtm331NmCvtOuIOr_6I",
				"use": "sig",
				"kid": "x5t-s256-unit-test",
				"alg": "ES256",
				"x5c": [
					"MIIBkjCCATegAwIBAgIUZkRih1mNAs9PfQphhjLx8O2Uej8wCgYIKoZIzj0EAwIwHTEbMBkGA1UEAwwSeDV0LXMyNTYtdW5pdC10ZXN0MCAXDTI2MDIwODE1NTEwMVoYDzIxMjYwMTE1MTU1MTAxWjAdMRswGQYDVQQDDBJ4NXQtczI1Ni11bml0LXRlc3QwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQx5OCxLnQFHvYuP74zEU9MvsM0rEKULKZ2qjWFnz/T1eXB8JKRu4i77bKgONYDaMHQLeEaPN73RPj+nlhpnoC3o1MwUTAdBgNVHQ4EFgQUQYMPimHGw8fD+nAw5hXN1tLeHE8wHwYDVR0jBBgwFoAUQYMPimHGw8fD+nAw5hXN1tLeHE8wDwYDVR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEAgyNkETTSsp/nkhXKjNETK4UGQXSayRAFtZ6hJSyKIOUCIQCIW7UskVfn6zliot/KzfmqY1XDjaTf6kzqhv5YBlRmtg=="
				],
				"x5t#S256": "DQV8phtgEie5m6PQEkEK4asleHFPXj1CwNrJ7lgJn-M"
			}]
		}
		""";

	/**
	 * JWK with x5c and a WRONG x5t#S256 - should cause a mismatch error.
	 */
	private static final String TEST_JWK_WITH_X5C_AND_WRONG_X5T = """
		{
			"keys": [{
				"kty": "EC",
				"crv": "P-256",
				"x": "MeTgsS50BR72Lj--MxFPTL7DNKxClCymdqo1hZ8_09U",
				"y": "5cHwkpG7iLvtsqA41gNowdAt4Ro83vdE-P6eWGmegLc",
				"d": "gwmApx70vcVlRzQid2uY-ooMjtm331NmCvtOuIOr_6I",
				"use": "sig",
				"kid": "x5t-s256-unit-test",
				"alg": "ES256",
				"x5c": [
					"MIIBkjCCATegAwIBAgIUZkRih1mNAs9PfQphhjLx8O2Uej8wCgYIKoZIzj0EAwIwHTEbMBkGA1UEAwwSeDV0LXMyNTYtdW5pdC10ZXN0MCAXDTI2MDIwODE1NTEwMVoYDzIxMjYwMTE1MTU1MTAxWjAdMRswGQYDVQQDDBJ4NXQtczI1Ni11bml0LXRlc3QwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAQx5OCxLnQFHvYuP74zEU9MvsM0rEKULKZ2qjWFnz/T1eXB8JKRu4i77bKgONYDaMHQLeEaPN73RPj+nlhpnoC3o1MwUTAdBgNVHQ4EFgQUQYMPimHGw8fD+nAw5hXN1tLeHE8wHwYDVR0jBBgwFoAUQYMPimHGw8fD+nAw5hXN1tLeHE8wDwYDVR0TAQH/BAUwAwEB/zAKBggqhkjOPQQDAgNJADBGAiEAgyNkETTSsp/nkhXKjNETK4UGQXSayRAFtZ6hJSyKIOUCIQCIW7UskVfn6zliot/KzfmqY1XDjaTf6kzqhv5YBlRmtg=="
				],
				"x5t#S256": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
			}]
		}
		""";

	@BeforeEach
	public void setUp() throws Exception {
		cond = new SignIdTokenWithX5tS256();
		cond.setProperties("UNIT-TEST", eventLog, ConditionResult.INFO);

		claims = JsonParser.parseString("""
			{
				"iss": "https://server.example.com",
				"sub": "user123",
				"aud": "client123",
				"iat": 1509992000,
				"exp": 1509992060,
				"nonce": "abc123"
			}
			""").getAsJsonObject();

		jwksWithX5c = JsonParser.parseString(TEST_JWK_WITH_X5C).getAsJsonObject();
		jwksWithoutX5cOrX5t = JsonParser.parseString(TEST_JWK_WITHOUT_X5C).getAsJsonObject();
		jwksWithX5tOnly = JsonParser.parseString(TEST_JWK_WITH_X5T_ONLY).getAsJsonObject();
		jwksWithX5cAndMatchingX5t = JsonParser.parseString(TEST_JWK_WITH_X5C_AND_MATCHING_X5T).getAsJsonObject();
		jwksWithX5cAndWrongX5t = JsonParser.parseString(TEST_JWK_WITH_X5C_AND_WRONG_X5T).getAsJsonObject();
	}

	@Test
	public void testEvaluate_x5tS256IsCorrectlyComputed() {
		env.putObject("id_token_claims", claims);
		env.putObject("server_jwks", jwksWithX5c);

		cond.execute(env);

		String idToken = env.getString("id_token");
		assertThat(idToken).isNotNull();

		try {
			SignedJWT jwt = SignedJWT.parse(idToken);
			JWSHeader header = jwt.getHeader();

			// Verify x5t#S256 is present and matches expected value
			Base64URL x5tS256 = header.getX509CertSHA256Thumbprint();
			assertThat(x5tS256).isNotNull();
			assertThat(x5tS256.toString()).isEqualTo(EXPECTED_X5T_S256);

			// Verify the claims are preserved
			JsonObject foundClaims = JWTUtil.jwtClaimsSetAsJsonObject(jwt);
			assertThat(foundClaims).isEqualTo(claims);

		} catch (ParseException e) {
			fail("Failed to parse signed JWT: " + e.getMessage());
		}
	}

	@Test
	public void testEvaluate_errorWhenNeitherX5cNorX5tPresent() {
		env.putObject("id_token_claims", claims);
		env.putObject("server_jwks", jwksWithoutX5cOrX5t);

		assertThrows(ConditionError.class, () -> {
			cond.execute(env);
		});
	}

	@Test
	public void testEvaluate_x5tS256UsedWhenOnlyX5tPresent() {
		env.putObject("id_token_claims", claims);
		env.putObject("server_jwks", jwksWithX5tOnly);

		cond.execute(env);

		String idToken = env.getString("id_token");
		assertThat(idToken).isNotNull();

		try {
			SignedJWT jwt = SignedJWT.parse(idToken);
			JWSHeader header = jwt.getHeader();

			Base64URL x5tS256 = header.getX509CertSHA256Thumbprint();
			assertThat(x5tS256).isNotNull();
			assertThat(x5tS256.toString()).isEqualTo(EXPECTED_X5T_S256);
		} catch (ParseException e) {
			fail("Failed to parse signed JWT: " + e.getMessage());
		}
	}

	@Test
	public void testEvaluate_successWhenBothPresentAndMatch() {
		env.putObject("id_token_claims", claims);
		env.putObject("server_jwks", jwksWithX5cAndMatchingX5t);

		cond.execute(env);

		String idToken = env.getString("id_token");
		assertThat(idToken).isNotNull();

		try {
			SignedJWT jwt = SignedJWT.parse(idToken);
			JWSHeader header = jwt.getHeader();

			Base64URL x5tS256 = header.getX509CertSHA256Thumbprint();
			assertThat(x5tS256).isNotNull();
			assertThat(x5tS256.toString()).isEqualTo(EXPECTED_X5T_S256);
		} catch (ParseException e) {
			fail("Failed to parse signed JWT: " + e.getMessage());
		}
	}

	@Test
	public void testEvaluate_errorWhenBothPresentAndMismatch() {
		env.putObject("id_token_claims", claims);
		env.putObject("server_jwks", jwksWithX5cAndWrongX5t);

		assertThrows(ConditionError.class, () -> {
			cond.execute(env);
		});
	}

}
